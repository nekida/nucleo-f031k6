# Мигаем светодидом без библиотеки

## Вводная
Решил повторить [проект](https://github.com/satoshinm/pill_blink), в котором сравнивается размер .bin файла с использованием (или без) разных библиотек. Мне понравилась реализация, названная разработчиком [bare-metal](https://github.com/satoshinm/pill_blink/tree/master/bare-metal). Ее повторю на другой плате с другим МК.

1. Делать буду на плате NUCLEO-F031K6 с контроллером STM32F031K6T6.

2. Поскольку делать это буду в Windows из-под STM32CubeIDE, придется извернуться: создать пустой проект в кубе или в самой IDE для контроллера и выкинуть все файлы, включая startup, оставив только STM32F031K6TX_FLASH.ld. Это нужно, чтобы IDE подтянуло все настройки, необходимые для сборки, отладки и загрузки на плату прошивки. Создаем файл reset.c, в котором потом будем писать код программы.

## Пишем код
### Скрипт сборки
В полноценном проекте должно присутствовать как минимум два файла: линкер скрипт и файл с кодом программы. 

Скрипт сборки  - это STM32F031K6TX_FLASH.ld. Правим его, удалив все сгенерированное кубом. Память состоит из двух частей: flash (чтение-выполнение (rx), начальный адрес 0x800_0000 и размер 32 КБайта) и ram (чтение-запись-выполнение (rwx), начальный адрес 0x2000_0000 и размер 4 КБайта). EXTERN(vector_table) - переменная vector_table определена в другом файле, ENTRY(reset_handler) - выполнение начнется с reset_handler.

Секция text - это текст программы, его размещаем во флэше. Программа содержит таблицу векторов прерываний и собственно текст. Выравниваем все на границе 4 байта (ALIGN(4)).

Что мы сделали: объявили регионы памяти, их начальные адреса, права доступа и размеры. Указали в каком порядке в секции text лежат переменные и объявили точку входа. 

### Текст программы
#### Создание переменной
Создаем структуру vector_table, содержащую два поля: указаетль на вершину стека (адрес конца ram) и указатель на функцию типа void (*p) (void). Атрибут ((section(".vectors"))) указывает линковщику разместить ее в секции векторов во флэше. Назначаем указателю на фукнцию реализацию функции reset_handler.

#### Реализация вектора сброса
Атрибут ((naked)) указывает линковщику не создавать так называемый код пролога и эпилога (или переключение контекста): [ARM Function Attributes](https://gcc.gnu.org/onlinedocs/gcc/ARM-Function-Attributes.html#ARM-Function-Attributes). Ну а теперь работа с регистрами, точнее, с их адресами.

#### Запись по адресам
Мало просто знать значение адреса. Для того, чтобы по адресу записать что-то - нужно превратить его в указатель: *(volatile unsigned int *). Можно было заменить "unsigned int" на "uin32_t", но это потребует подключение stdint.h. 

Диод расположен на ноге PB3. High - горит, Low - потушен. Разрешаем тактирование порта через регистр RCC_AHBENR, настраиваем пожку на выход и выбираем самую высокую скорость (output push-pull режим устанавливается сразу после подачи питания - регистр OTYPER не трогаем).

В бесконечном цикле, используя регистр BSRR выставляем на ножке порта 1, ждем 1 000 000 циклов выполнения команды "nop", выставляем на ножке порта уже 0 и снова ждем.

